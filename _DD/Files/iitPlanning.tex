Following the idea of the Three Layers architecture, also the implementation of the platform can be grossly divided in three main chunks.
Theese parts interact with each other thanks to the use of interfaces, this allows to implement them independently and simultaneously. So the first step is to implement rigourously their definition, specifying how messages are composed and how they are exchanged between the components.\\

\subsection{Data Layer}
The Data Layer comprises database implementation and the implementation of the interfaces that allow the Application Layer to interact with it.\\
Each component of this layer has to be tested independently, then once they are all implemented, can be integrated and tested together, using also Drivers that emulate the behaviour of the Application Logic Layer.\\
\subsection{Application Logic Layer}
Given the chosen architecture, this Layer needs a more detailed plan. Among Microservices can be identified some dependencies shown in the following graph:

%\useSvgWithCaption{}{}{}{}

Given the internal structure of this Layer, all Microservices depend on the Dispatcher. This is a Key component, since each communciation between Microservices is mediated by it, so it has to be implemented first.\\
Then can be implemented the DBMSManager, that can be chosen as secon most important component thanks to its interaction with the Data Layer. Then starting from it and following with a bottom-up approach, other Microservices can be implemented.\\
The last microservices to be realized are the ones that interact with the Presentation logic level, since those does not depend on any other component.\\
Each component has to be subjected to unit testing, then can be integrated first with the Dispatcher and then with the other components, running all necessary tests.\\
Given the fact that the Dispatcher is the component that does load balancing, components have to be stressed for proving that the dispatcher is able to allocate more resources, and the dispatcher itself has to be tested with an high ammount of similar requests to check if it manages them equally among resources.\\

\subsection{Presentation Logic Layer}
The Presentation Layer is comprised of the implementation of the Web Server, The API, the Web App that runs on client's browser, the RMP action and the confirmation links.\\
This part is formed by few components than other Layers, but the complexity of each one is higher. Here follows the dependency graph of the components:
DIAGRAM HERE\\
Can be noticed how the Web Server component, having the job of connecting the Application Logic to Presentation Level is the most critical Layer, and has to be implemented first. In fact it contains all logic needed to manage the API calls and forward them to the Application Logic.\\
Then after implementing the API, the other components are totally separted between each other and can be realized independently and in parallel.\\   
Given the Crucial nature of this component, this has to be tested both for functionality and for security. \\

\subsection{Integration of the Layers}
Thanks the use of the necessary Drivers and Stubs, each Layer, once implemented, can be tested independently. Then once all Layers are implemented and tested, the whole system can be integrated and tested as a whole.\\