Following the idea of the Three level architecture, also the implementation of the platform can be grossly divided in three main chunks.
Theese chunks interact with each other thanks the use of interfaces, this allows to implement them independently and simultaneously. So the first step is to implement rigourously the definition of the interfaces, defining how messages are composed and how they are exchanged between the components.\\

\subsection{Data Layer}
The Data layer comprises of the Implementation of the database and the implementation of the interfaces that allow the Application Layer to interact with it.\\
Each component of this layer has to be tested independently, then once they are all implemented, can be integrated and tested together, using also Drivers that emulate the behaviour of the Application Logic Layer.\\
\subsection{Application Logic Layer}
Given the chosen architecture, this layer needs a more detailed plan. Between the Microservices can be identified some dependencies shown in the following graph:

DIAGRAM HERE, STEP BY STEP GOING UP UNTIL THE CONTROLLER - FOLLOW THE SEQUENCE DIAGRAMS FOR FINDING THE DEPENDENCIES

Given the internal structure of this Layer, all Microsercives depend to the Dispatcher. This is a Key component, since each communciation between the Microservices is mediated by it, so it has to be implemented first.\\
Then can be implemented the DBMSManager, being this one the responsible of the interaction with the Data Layer is, after the Dispatcher, the second most important component. Then starting from it and following with a bottom-up approach the other Microservices can be implemented.\\
The last microservices to be implemented are the ones that interact with the Presentation logic level, since those are not dependent with any other component.\\
Each component has to be subjected to unit testing, then can be integrated first with the Dispatcher and then with the other components, running ll necessary tests.\\
Given that the Dispatcher is the component that does load balancing, components have to be stressed for proving that the dispatcher is able to allocate more resources, and the dispatcher itself has to be tested with an high ammount of similar requests to check if it manages them equally among resources\\

\subsection{Presnetation Logic Layer}
The Presentation Layer is comprised of the implementation of the Web Server, The API, the Web App that runs on client's browser, the RMP action and the confirmation links.\\
Here the number of compnents is lower than the other layers, but the complexity of each one is higher. Here follows the dependency graph of the components:
DIAGRAM HERE
Can be noted how the Web Server component, having the job of connecting the Application logic to the presentation is the most critical one of the layer, and has to be implemented first. Infact it contains all logic needed to manage the API calls and forward them to the Application Logic Layer.\\
Then after implementing the API, the other components are totally separted between each other and can be implemented independently and in parallel.\\   
Given the Crucial nature of this component, this has to be tested both for functionality and for security. \\

\subsection{Integration of the Layers}
Thanks the use of the necessary Drivers and Stubs, each layer once implemented can be tested independently. Then once all layers are implemented and tested, the whole system can be integrated and tested as a whole.\\